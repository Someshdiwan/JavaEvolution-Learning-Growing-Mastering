Understanding Stateful and Stateless Operations in Java Streams:

In Java Streams, operations are classified as either **stateless** or **stateful** based on
how they process the data and whether they require maintaining state across elements.

1. Stateless Operations

Definition:
These operations process each element independently, without relying on the elements before
or after it. They do not maintain any internal state.

Examples:
- filter(Predicate)  → Filters elements based on a condition.
- map(Function)      → Transforms each element.
- flatMap(Function)  → Flattens nested collections.
- peek(Consumer)     → Performs an action on each element.
- forEach(Consumer)  → Iterates over elements.

Example Code:

import java.util.Arrays;
import java.util.List;

public class StatelessExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        numbers.stream()
               .filter(x -> x % 2 == 0)   // Stateless
               .map(x -> x * 2)           // Stateless
               .forEach(System.out::println);
    }
}

Output:
4
8

Why Stateless?
- Each element is processed independently without tracking previous or future elements.

---------------------------------------------------------------
2. Stateful Operations
---------------------------------------------------------------

Definition:
These operations require keeping track of previously seen elements or processing the entire
stream before producing output. They may require buffering or sorting.

Examples:
- distinct()  → Removes duplicate elements.
- sorted()    → Sorts the elements.
- limit(n)    → Returns the first n elements.
- skip(n)     → Skips the first n elements.
- collect()   → Collects results into a collection.
- reduce()    → Reduces all elements to a single value.

Example Code:

import java.util.Arrays;
import java.util.List;

public class StatefulExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(5, 3, 7, 1, 5, 3);

        numbers.stream()
               .distinct()                // Stateful (removes duplicates)
               .sorted()                  // Stateful (needs to sort entire stream)
               .forEach(System.out::println);
    }
}

Output:
1
3
5
7

Why Stateful?
- distinct() needs to track seen elements to remove duplicates.
- sorted() must process the entire stream to produce an ordered result.

---------------------------------------------------------------
3. Why Does It Matter?
---------------------------------------------------------------

Performance Considerations:
- Stateless operations are faster and process element-by-element.
- Stateful operations may require buffering and increase memory usage.

Parallel Streams:
- Stateless operations are well suited for parallel execution.
- Stateful operations may need synchronization and can degrade performance in parallel streams.

Example: Parallel with Stateless vs Stateful

import java.util.Arrays;
import java.util.List;

public class ParallelExample {
    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6);

        // Stateless works well in parallel
        nums.parallelStream()
            .filter(x -> x % 2 == 0)
            .forEach(System.out::println);

        // Stateful may disrupt order in parallel
        nums.parallelStream()
            .sorted()
            .forEach(System.out::println);
    }
}

- Stateless → Independent per-element operations, efficient, good for parallel streams.
- Stateful  → Require knowledge of entire stream or previously processed elements, ay reduce efficiency,
              especially in parallel.
