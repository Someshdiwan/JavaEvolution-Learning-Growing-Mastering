name: Telegram Notifier

on:
  push:
    branches: ["**"]
    tags: ["*"]
  pull_request:
    types: [opened, reopened, synchronize, closed]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      title:
        description: "Manual title (e.g. ðŸ“¢ Announcement)"
        required: false
        default: "ðŸ“¢ Manual"
      text:
        description: "Message to send"
        required: true
      chat_id:
        description: "Override TG_CHAT_ID (e.g. @Channel or numeric id)"
        required: false

permissions:
  contents: read

concurrency:
  group: telegram-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: false

jobs:
  notify:
    runs-on: ubuntu-latest
    environment: SANDBOX  # must contain secrets TG_BOT_TOKEN and TG_CHAT_ID

    steps:
      - name: Checkout (for commit log)
        uses: actions/checkout@v4
        with:
          fetch-depth: 50

      - name: Build message (plain text)
        id: msg
        shell: bash
        env:
          REPO: ${{ github.repository }}
          ACTOR: ${{ github.actor }}
          EVENT: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          REPO_URL: ${{ github.server_url }}/${{ github.repository }}

          GIT_BEFORE: ${{ github.event.before }}
          GIT_SHA: ${{ github.sha }}

          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_ACTION: ${{ github.event.action }}
          PR_MERGED: ${{ github.event.pull_request.merged }}

          REL_TAG: ${{ github.event.release.tag_name }}
          REL_NAME: ${{ github.event.release.name }}
          REL_URL: ${{ github.event.release.html_url }}

          WD_TEXT:  ${{ github.event.inputs.text }}
          WD_TITLE: ${{ github.event.inputs.title }}
        run: |
          set -euo pipefail

          header() {
            printf '%s\nRepo: %s\nBy: %s\nRef: %s\nRun: %s\n' \
              "$1" "$REPO" "$ACTOR" "$REF_NAME" "$RUN_URL"
          }

          MESSAGE=""

          if [[ "$EVENT" == "workflow_dispatch" ]]; then
            TITLE="${WD_TITLE:-ðŸ“¢ Manual}"
            MESSAGE="$(header "$TITLE")"
            [[ -n "${WD_TEXT:-}" ]] && MESSAGE+=$'\n'"${WD_TEXT}"

          elif [[ "$EVENT" == "push" ]]; then
            BEFORE="${GIT_BEFORE:-}"
            AFTER="$GIT_SHA"

            if [[ -z "$BEFORE" || "$BEFORE" =~ ^0+$ ]]; then
              mapfile -t LINES < <(git log -n 10 --pretty=format:'%s%x1f%h' "$AFTER" || true)
            else
              mapfile -t LINES < <(git log --pretty=format:'%s%x1f%h' "$BEFORE..$AFTER" | head -n 10 || true)
            fi

            COMMITS=""
            if [[ ${#LINES[@]} -eq 0 ]]; then
              COMMITS="- (no commit messages found)"
            else
              ACTOR_URL="https://github.com/${ACTOR}"
              for row in "${LINES[@]}"; do
                IFS=$'\x1f' read -r subj short <<<"$row"
                COMMITS+="- ${subj} (${short}) by ${ACTOR_URL}"$'\n'
              done
              COMMITS="${COMMITS%$'\n'}"
            fi

            MESSAGE="$(header 'ðŸ“£ Last 10 commits')"
            MESSAGE+=$'\n'"${COMMITS}"$'\n\n'"Repo: ${REPO_URL}"

          elif [[ "$EVENT" == "pull_request" ]]; then
            if [[ "$PR_ACTION" == "closed" ]]; then
              [[ "${PR_MERGED}" == "true" ]] && STATUS="PR merged âœ…" || STATUS="PR closed âŒ"
            else
              STATUS="PR updated âœï¸"
            fi
            MESSAGE="$(header "$STATUS")"
            MESSAGE+=$'\n'"#${PR_NUMBER}: ${PR_TITLE}"$'\n'"${PR_URL}"

          elif [[ "$EVENT" == "release" ]]; then
            NAME="${REL_NAME:-$REL_TAG}"
            MESSAGE="$(header 'Release published ðŸ·ï¸')"
            MESSAGE+=$'\n'"Tag: ${REL_TAG}"$'\n'"Name: ${NAME}"$'\n'"${REL_URL}"

          else
            MESSAGE="$(header "Event: $EVENT")"
          fi

          # Write multi-line output safely (no EOF pitfalls)
          {
            printf 'text<<MSGEOF\n'
            printf '%s\n' "$MESSAGE"
            printf 'MSGEOF\n'
          } >> "$GITHUB_OUTPUT"

      - name: Send to Telegram (plain text)
        shell: bash
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID_DEFAULT: ${{ secrets.TG_CHAT_ID }}
          TEXT: ${{ steps.msg.outputs.text }}
          OVERRIDE_CHAT_ID: ${{ github.event.inputs.chat_id }}
        run: |
          set -euo pipefail
          CHAT_ID="${OVERRIDE_CHAT_ID:-$TG_CHAT_ID_DEFAULT}"
          [[ -n "${TG_BOT_TOKEN:-}" && -n "${CHAT_ID:-}" ]] || { echo "Missing TG secrets"; exit 1; }

          # Send as plain text (no parse_mode) so spacing/lines stay exactly as built
          RESP="$(curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n \
                  --arg chat_id "$CHAT_ID" \
                  --arg text "$TEXT" \
                  '{chat_id:$chat_id, text:$text, disable_web_page_preview:true}')")"

          echo "Telegram response: $RESP"
          echo "$RESP" | jq -e '.ok == true' >/dev/null

          echo "âœ… Message sent to Telegram."
