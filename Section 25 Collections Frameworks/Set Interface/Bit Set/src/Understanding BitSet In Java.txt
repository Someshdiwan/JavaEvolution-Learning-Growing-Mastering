Understanding BitSet in Java:

## What is BitSet?

- A **specialized class in java.util** for handling sets of bits (true/false flags).
- Internally uses an array of **long integers (64-bit chunks)** to represent bits efficiently.
- Provides a **compact, memory-efficient way** to store and manipulate boolean values.
- Useful when working with **large collections of flags, switches, or binary data**.

---

## Key Characteristics

- **Indexed Access:** Bits are indexed starting at 0.
- **Dynamic Sizing:** BitSet grows automatically as needed (no fixed size).
- **Compact Storage:** Each bit requires only 1/8 of a byte.
- **Boolean Semantics:** A bit is either set (true) or clear (false).
- **Not Thread-Safe:** External synchronization required for concurrent access.
- **Bitwise Operations Supported:** AND, OR, XOR, ANDNOT between BitSets.
- **Conversion Methods:** Can convert to/from byte arrays and streams.

---

## Internal Working

- Uses an internal `long[]` array.
- Each `long` has 64 bits, where each bit represents one boolean value.
- Bit at position `n` is stored in:

longIndex = n / 64
bitIndex  = n % 64

- To set a bit → perform `OR` with a mask.
- To clear a bit → perform `AND` with an inverted mask.
- To flip a bit → perform `XOR` with a mask.

### Example (BitSet of size 10)

Index:   0 1 2 3 4 5 6 7 8 9
Bits:    1 0 1 1 0 0 1 0 0 1

Meaning:
	•	Bit 0 = 1 (true)
	•	Bit 1 = 0 (false)
	•	Bit 2 = 1 (true)
…

---

## Complexity Chart

| Operation              | Time Complexity | Notes                                      |
|------------------------|-----------------|--------------------------------------------|
| set(bitIndex)          | O(1)            | Bitwise operation on correct long index.   |
| clear(bitIndex)        | O(1)            | Reset a single bit.                        |
| flip(bitIndex)         | O(1)            | Toggle a single bit.                       |
| get(bitIndex)          | O(1)            | Test if bit is set.                        |
| and(BitSet)            | O(n/64)         | Bitwise AND over internal longs.           |
| or(BitSet)             | O(n/64)         | Bitwise OR over internal longs.            |
| xor(BitSet)            | O(n/64)         | Bitwise XOR over internal longs.           |
| cardinality()          | O(n/64)         | Counts set bits (population count).        |
| size()                 | O(1)            | Returns storage size in bits.              |

---

## Differences vs Other Collections

| Feature              | ArrayList<Boolean>        | HashSet<Integer> (storing indices) | BitSet                                 |
|----------------------|---------------------------|-------------------------------------|---------------------------------------|
| Storage Efficiency   | High memory (1 byte/flag) | Very high memory (object overhead)  | Extremely compact (1 bit per flag)    |
| Performance          | O(1) per access           | O(1) average per access             | O(1) bitwise access                   |
| Ordering             | Index-based               | Unordered                           | Index-based                           |
| Null Handling        | Allows null               | Allows null                         | No null (only bits)                   |
| Use Case             | Small collections         | Generic uniqueness of numbers       | Large-scale flags, bit-level ops      |

---

## When to Use BitSet?

- When you need to **store or manipulate a large set of boolean values** compactly.
- Ideal for:
  - **Flags & Switches:** Represent feature toggles, permissions.
  - **Bloom Filters:** Efficient probabilistic data structures.
  - **Graph Algorithms:** Track visited nodes.
  - **Compression Tasks:** Represent binary states compactly.
  - **Mathematical Sets:** Perform fast union, intersection, difference.

---

## Quick Recap

- **BitSet** stores bits using a `long[]`.
- Extremely **memory-efficient** compared to other collections.
- Supports **fast bitwise operations** (AND, OR, XOR).
- Automatically resizes as needed.
- Best suited for **large-scale boolean operations**.
