ðŸ“Š LinkedHashMap vs LinkedHashMap as LRU Cache
==============================================

| Feature                        | Plain LinkedHashMap                            | LinkedHashMap as LRU Cache                        |
|--------------------------------|------------------------------------------------|--------------------------------------------------|
| **Ordering Mode**              | Insertion order by default                     | Access order (`accessOrder = true`)              |
| **Reordering on Access**       | âŒ No reordering (keys stay in inserted order)  | âœ… Keys move to the end when accessed/updated     |
| **Eviction Policy**             | âŒ None (entries remain until removed manually) | âœ… `removeEldestEntry()` can evict least recent   |
| **removeEldestEntry()**        | Default â†’ always `false`                       | Overridden â†’ returns `true` if size > capacity   |
| **Use Case**                   | When you just need predictable iteration order | When you need an **LRU cache**                   |
| **Example Behavior**           | Put(A), Put(B), Put(C) â†’ [A, B, C]             | Put(A), Put(B), Put(C), Get(A), Put(D) â†’ [C, A, D] |
| **Memory Management**          | No auto-cleanup                                | Oldest (least recently used) entries auto-removed|
| **Performance**                | O(1) for get/put                               | O(1) for get/put + eviction check (still O(1))   |

---

âœ… **Key Insight:**
- **Plain LinkedHashMap** = maintains *insertion order*.
- **LinkedHashMap with `accessOrder=true` + `removeEldestEntry()`** = behaves like an **LRU Cache**.

ðŸ‘‰ Thatâ€™s why **LinkedHashMap is the backbone of many Java cache implementations**.
