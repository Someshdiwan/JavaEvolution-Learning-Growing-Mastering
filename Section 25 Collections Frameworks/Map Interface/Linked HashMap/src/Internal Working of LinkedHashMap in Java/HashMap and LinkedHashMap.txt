HashMap and LinkedHashMap so you clearly see why one preserves order and the other doesnâ€™t.

â¸»

ğŸ”¹ HashMap (No Order Guarantee)

Keys inserted: "Shubham", "Bob", "Akshit"

Internal Structure (buckets):

Bucket[0] : null
Bucket[1] : ("Bob" -> 80)
Bucket[2] : ("Akshit" -> 78)
Bucket[3] : ("Shubham" -> 92)
Bucket[4] : null
...
Bucket[15]: null

Iteration â†’ Goes bucket by bucket:
Output may look like: {Akshit=78, Shubham=92, Bob=80}

âŒ Order is NOT insertion-based
âŒ Order is NOT access-based

â€¢	Why unordered? Because keys are placed in buckets based on hashCode % capacity.
â€¢	Iteration just walks bucket array â†’ so order looks random.

â¸»

ğŸ”¹ LinkedHashMap (accessOrder = false â†’ Insertion Order)

Keys inserted: "Orange", "Apple", "Guava"

Doubly Linked List (insertion order maintained):

HEAD <-> Orange(10) <-> Apple(20) <-> Guava(13) <-> TAIL

Iteration output:
Orange=10
Apple=20
Guava=13

	â€¢	Preserves insertion order by default.

â¸»

ğŸ”¹ LinkedHashMap (accessOrder = true â†’ Access Order)

Keys inserted: "Orange", "Apple", "Guava"
Access pattern: get("Apple"), get("Orange"), get("Guava")

Doubly Linked List (reordered on access):

HEAD <-> Apple(20) <-> Orange(10) <-> Guava(13) <-> TAIL

Iteration output:
Apple=20
Orange=10
Guava=13

	â€¢	Every time an entry is accessed, it is moved to the end.
	â€¢	Newest (most recently accessed) items go at the tail.
	â€¢	Oldest (least accessed) stay near the head.

This mechanism is exactly how LRU Cache is built using LinkedHashMap.

â¸»

âš¡ Quick Recap:
	â€¢	HashMap â†’ Bucket-based, order = unpredictable.
	â€¢	LinkedHashMap (Insertion Order) â†’ Order of insertion is preserved.
	â€¢	LinkedHashMap (Access Order) â†’ Reorders entries based on access (like LRU).

â¸»
