How the JVM maps your Thread objects to real operating system threads,
how they communicate with the OS scheduler, and how synchronization works.

Java Threads and OS Threads (pthreads)

                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚          Your Java Program            â”‚
                          â”‚     (Running inside the JVM)          â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                           â”‚
                                           â–¼
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚              JVM Runtime               â”‚
                          â”‚----------------------------------------â”‚
                          â”‚  Thread Table / Thread Manager         â”‚
                          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                          â”‚  â”‚ Java Thread Objects (Heap)      â”‚   â”‚
                          â”‚  â”‚  + Thread ID                    â”‚   â”‚
                          â”‚  â”‚  + Runnable target              â”‚   â”‚
                          â”‚  â”‚  + Stack reference              â”‚   â”‚
                          â”‚  â”‚  + State (RUNNABLE, WAITING...) â”‚   â”‚
                          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                          â”‚             â”‚              â”‚           â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚              â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                                                                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Native Thread (T1) â”‚  <-- created via pthread_create()                          â”‚ Native Thread (T2) â”‚
â”‚ (C-level pthread)  â”‚  (mapped 1:1 with Java Thread)                             â”‚ (C-level pthread)  â”‚
â”‚--------------------â”‚                                                            â”‚--------------------â”‚
â”‚ OS Thread Stack    â”‚                                                            â”‚ OS Thread Stack    â”‚
â”‚ Thread Registers   â”‚                                                            â”‚ Thread Registers   â”‚
â”‚ OS Scheduler Entry â”‚                                                            â”‚ OS Scheduler Entry â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                                                                                  â”‚
          â–¼                                                                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Kernel / OS       â”‚                                        â”‚         Kernel / OS       â”‚
â”‚---------------------------â”‚                                        â”‚---------------------------â”‚
â”‚ CPU Scheduler (time-slice)â”‚ â† Schedules native threads on cores â†’  â”‚ CPU Scheduler (time-slice)â”‚
â”‚ Context Switching         â”‚                                        â”‚ Context Switching         â”‚
â”‚ Synchronization Primitivesâ”‚ â† mutexes, semaphores, futexes         â”‚ Synchronization Primitivesâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ§  Breakdown of the Layers

1ï¸âƒ£ Java Thread Layer (User Code)
When you write:

new Thread(runnable).start();

youâ€™re creating a Java object (on the JVM heap) that holds metadata â€” name, priority, state â€” and
a reference to your Runnable code.

â¸»

2ï¸âƒ£ JVM Thread Manager
The JVM has an internal thread table to manage all live threads.

When you call .start(), the JVM:
1.	Allocates a native thread (via pthread_create() on Linux/macOS, CreateThread() on Windows).
2.	Attaches the Java thread object to it.
3.	Initializes a separate native stack for that thread.

Thatâ€™s why modern JVMs (HotSpot, OpenJ9, GraalVM) are called 1:1 threading models â€” every Java thread = one native
thread.

â¸»

3ï¸âƒ£ Native Thread (OS-level)
Each thread runs your Java bytecode inside its own call stack.
The OS scheduler time-slices them across available CPU cores, just like any C pthread.

So when two Java threads run concurrently:
â€¢	The JVM doesnâ€™t â€œfakeâ€ concurrency.
â€¢	It truly runs two native threads in parallel (subject to CPU availability).

â¸»

4ï¸âƒ£ Kernel and CPU Scheduler
At the bottom, everything hits the same real-world machinery:
â€¢	The CPU scheduler decides which threads run.
â€¢	The kernel provides synchronization primitives (mutexes, futexes, semaphores) that
the JVM uses to implement synchronized, wait(), notify(), and Lock mechanisms.


Essentially, when you write:

synchronized (obj) { ... }

youâ€™re indirectly triggering an OS-level mutex or futex lock.

â¸»

ğŸ§© Java Virtual Threads (Project Loom) â€” The New Layer

In modern Java (19+ preview, 21+ stable), virtual threads were introduced â€”
a revolutionary abstraction that changes the top layer of this diagram.


Hereâ€™s a simplified update:

[ Java Virtual Thread ]
       â”‚
       â–¼
[ JVM Scheduler (user-mode) ]
       â”‚
       â–¼
[ Shared Native Thread (pthread) ]


Instead of mapping every Java thread to a real OS thread (which is heavy),
many virtual threads are multiplexed on a smaller pool of carrier OS threads.


That means the JVM handles the scheduling itself, in user space, making millions of threads feasible.

So:
â€¢	Traditional threads â†’ 1:1 mapping to native pthreads.
â€¢	Virtual threads â†’ M:N mapping (many Java threads on fewer native threads).

â¸»

Summary

| Concept         | C (pthread)              | Java Classic Threads        | Java Virtual Threads                   |
|-----------------|--------------------------|-----------------------------|----------------------------------------|
| Thread Creation | pthread_create()         | new Thread().start()        | Thread.ofVirtual().start()             |
| OS Mapping      | 1:1                      | 1:1                         | M:N                                    |
| Scheduler       | OS kernel                | OS kernel                   | JVM user-space                         |
| Stack           | Fixed native stack       | Native stack                | Lightweight heap stack                 |
| Context Switch  | Kernel mode              | Kernel mode                 | User mode (cheap) inside JVM container |

â¸»

This architectural stack is the same skeleton under every Java concurrency construct
â€” Thread, ExecutorService, ForkJoinPool, CompletableFuture, and now Virtual Threads
â€” all ride atop those native pthreads or their virtualized successors.
