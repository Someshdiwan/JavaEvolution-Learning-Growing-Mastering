A bounded queue** has a fixed maximum capacity â€” it cannot grow beyond its limit.

When the queue is full, producers attempting to insert elements block until space
becomes available or until a timeout occurs (depending on the method used).

In Java:
- `ArrayBlockingQueue` â†’ always bounded**, capacity fixed at creation.
- `LinkedBlockingQueue` â†’ can be explicitly bounded via constructor.
- `SynchronousQueue` â†’ zero-capacity, special case where capacity = 0.

This design helps prevent memory exhaustion by throttling producers when consumers
cannot keep up.

Bounded Queue (e.g., `ArrayBlockingQueue`)

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚     Bounded BlockingQueue  â”‚
          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
Producer â†’â”‚ [Slot1] [Slot2] [Slot3]    â”‚â†’ Consumer
          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
          â”‚  â€¢ Fixed capacity (e.g., 3)â”‚
          â”‚  â€¢ put() blocks if full    â”‚
          â”‚  â€¢ take() blocks if empty  â”‚
          â”‚  â€¢ Ensures backpressure    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ASCII Flow Example

Producer threads:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Producer1 â”‚ â†’â†’â†’ â”‚ Producer2 â”‚ â†’â†’â†’ â”‚ Producer3 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                â”‚                â”‚
        â–¼                â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Queue: [Task1][Task2][Task3] (FULL)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
        ğŸ’¤ Producers block until Consumer takes()

Consumer thread:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Consumer1 â”‚ â†’ consumes â†’ frees space â†’ producers resume
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Summary of Behavior

| Queue Type               | Capacity Type     | put() when Full            | take() when Empty          | Example Use Case                 |
|--------------------------|-------------------|----------------------------|----------------------------|----------------------------------|
| `ArrayBlockingQueue`     | Bounded           | Blocks                     | Blocks                     | Thread throttling, load control  |
| `LinkedBlockingQueue`    | Bounded/Unbounded | Blocks if bounded & full   | Blocks                     | Mixed use, configurable          |
| `SynchronousQueue`       | Zero-capacity     | Always blocks until paired | Always blocks until paired | Direct thread handoff            |

In short:
A bounded queue enforces capacity limits and provides natural backpressure,
ensuring that producers slow down when the queue is full. Itâ€™s ideal for systems
where throughput must be controlled to prevent overloading memory or downstream
consumers.

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚     Bounded BlockingQueue  â”‚
          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
Producer â†’â”‚ [Slot1] [Slot2] [Slot3]    â”‚â†’ Consumer
          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
          â”‚  â€¢ Fixed capacity (e.g., 3)â”‚
          â”‚  â€¢ put() blocks if full    â”‚
          â”‚  â€¢ take() blocks if empty  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
