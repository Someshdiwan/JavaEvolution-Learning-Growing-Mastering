Internal Working of Stack in Java (Enhanced & Detailed)

* In Java, Stack is a legacy class from the java.util package.
* It extends Vector, which means:
o Backed by a dynamic array (like Vector).
o Inherits synchronization for thread safety.

* Represents a Last-In, First-Out (LIFO) data structure.
* Although still used, it is often replaced with ArrayDeque in modern applications due to performance advantages.

1. Underlying Data Structure

* Stack is built on top of Vector, which internally uses an array (Object[]) to store elements.
* Key points:
o The array resizes dynamically when capacity is exceeded.
o Synchronization makes operations thread-safe but slower.

Declaration:
Stack<Integer> stack = new Stack<>();

Internally:
Vector<Object> elementData = new Vector<>(initialCapacity);
* Default capacity starts at 10.
* Resizing: when the array is full, capacity is doubled.

2. Core Operations of Stack

push(E item)
* Adds element to the top of the stack.
* Internally calls addElement(item) from Vector.

Example:
stack.push(10); // adds 10 to stack top

Flow:
1. Check capacity.
2. If full ? grow array.
3. Place element at elementData[size].
4. Increment size.

pop()
* Removes and returns the top element.
* Internally:
o Retrieves last element via elementAt(size-1).
o Calls removeElementAt(size-1).

Example:
int x = stack.pop();

Flow:
1. Call peek() to get element.
2. Reduce size by 1.
3. Nullify the removed slot for GC.

peek()
* Returns the top element without removing it.
* Uses elementAt(size-1).
* Throws EmptyStackException if empty.

empty()
* Checks if the stack has no elements.
* Returns size() == 0.

search(Object o)
* Returns the 1-based position from the top of the stack.
* If not found, returns -1.
* Internally scans linearly (O(n)).

Complexity of Operations

* push(E) ? O(1) amortized (resizing may cost O(n)).
* pop() ? O(1).
* peek() ? O(1).
* empty() ? O(1).
* search() ? O(n) (linear search).


Code

Class Declaration
public class Stack<E> extends Vector<E> {
    public Stack() { }
}

push()
public E push(E item) {
    addElement(item); // Vector method
    return item;
}

pop()
public synchronized E pop() {
    E obj;
    int len = size();
    obj = peek();
    removeElementAt(len - 1);
    return obj;
}

peek()
public synchronized E peek() {
    int len = size();
    if (len == 0)
        throw new EmptyStackException();
    return elementAt(len - 1);
}

Example Code

import java.util.*;

public class StackDemo {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        stack.push(10);
        stack.push(20);
        stack.push(30);

        System.out.println("Stack: " + stack);     // [10, 20, 30]
        System.out.println("Top: " + stack.peek()); // 30

        stack.pop();
        System.out.println("After pop: " + stack); // [10, 20]

        System.out.println("Search 10: " + stack.search(10)); // 2
        System.out.println("Is empty? " + stack.empty());     // false
    }
}
