Internal Working of IdentityHashMap:

1. Key Comparison:
   - Unlike HashMap (which uses `equals()` + `hashCode()`),
   - IdentityHashMap uses **reference equality (==)** to compare keys.
   - Two objects with the same content but different memory addresses are treated as separate keys.

2. Buckets & Hashing:
   - Similar to HashMap, it uses hashing + an internal table (array) to store entries.
   - But during lookup/insert, it checks `(k1 == k2)` instead of `k1.equals(k2)`.

3. Collision Handling:
   - IdentityHashMap is also backed by open addressing (like HashMap).
   - If multiple keys hash to the same bucket, probing is done to find an empty slot.

4. Null Keys & Values:
   - Supports **null keys** and **null values**.
   - Since reference equality works with null, only **one null key** can exist.

5. Performance:
   - Slightly faster lookups in some cases (no equals() calls, just reference comparison).
   - But consumes more memory than HashMap due to open addressing.

6. Use Cases:
   âœ” Object identity tracking (caches, serialization, object pools).
   âœ” When you care about whether two references are the *exact same object*, not just logically equal.
   âœ˜ Avoid for general-purpose maps where logical equality matters.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ ASCII View:
 key1 ("Hello") â†’ [obj#1234]
 key2 ("Hello") â†’ [obj#5678]

 HashMap   â†’ considers them equal (one entry updated).
 IdentityHM â†’ keeps both separately since 1234 != 5678.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
âš™ï¸ Extended Theory
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

1. Comparison Logic:
   - HashMap â†’ `(k1 == null ? k2 == null : k1.equals(k2))`.
   - IdentityHashMap â†’ `(k1 == k2)` only.
   - So even if two objects have the same `hashCode()` and `equals()`,
     they are stored as separate entries if not the same reference.

2. Table Representation:
   - Internally uses an **array of Objects** with alternating slots:
     [Key0, Value0, Key1, Value1, Key2, Value2 ...]
   - This layout is different from HashMap (which stores Nodes/Entries in buckets).
   - Open addressing + linear probing handles collisions.

3. Hashing Behavior:
   - Uses `System.identityHashCode(key)` instead of `key.hashCode()`.
   - `System.identityHashCode()` gives a hash code derived from the
     objectâ€™s memory address (not overridable).
   - Ensures uniqueness based on actual object identity.

4. Null Handling:
   - Allows one `null` key because reference equality for `null` is straightforward.
   - Multiple `null` values are allowed.

5. Capacity & Load Factor:
   - Default capacity is 32.
   - Table size always a power of 2.
   - Default load factor = 2/3 (0.67).
   - On exceeding threshold, table grows (resized) with rehashing.

6. Performance:
   - Faster key comparisons (reference check instead of .equals()).
   - Memory overhead due to open addressing.
   - Average time complexity: O(1) for put/get/remove.
   - Worst case: O(n) if too many collisions.

7. Iteration:
   - Iteration order is undefined (like HashMap).
   - Uses backing array directly to iterate over keys/values.

8. Practical Use Cases:
   - Tracking object identities (not content equality).
   - Serialization frameworks (to track already visited objects).
   - Caches where identity is more important than equality.
   - Graph algorithms (e.g., detecting object references).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ ASCII Comparison: HashMap vs IdentityHashMap
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Suppose:
 key1 = new String("Hello") â†’ obj#1234
 key2 = new String("Hello") â†’ obj#5678

HashMap:
   Bucket â†’ { "Hello"=200 }   // key1 and key2 merged because equals() true.

IdentityHashMap:
   Table â†’ { obj#1234=100, obj#5678=200 }  // kept separately because 1234 != 5678.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ” Key Takeaway:
- IdentityHashMap is a **special-purpose Map**.
- Do NOT use it when you expect logical equality of keys.
- Perfect when reference identity is the only requirement.
