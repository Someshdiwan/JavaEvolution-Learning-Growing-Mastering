Queue Interface in Java:

Definition:
The Queue interface (java.util.Queue) is a part of the Java Collections Framework.
It represents a collection designed for holding elements *prior to processing* (FIFO — First In, First Out).

Key Features of Queue:
1. Ordering
   - Typically maintains elements in FIFO order (first element inserted is the first to be removed).
   - Some implementations (like PriorityQueue) order elements by priority instead.

2. Insertion & Removal Operations
   - `offer(E e)` → inserts an element (returns false if capacity restrictions prevent insertion).
   - `add(E e)` → similar to offer but throws exception if insertion fails.
   - `poll()` → retrieves and removes the head (returns null if empty).
   - `remove()` → similar to poll but throws exception if empty.
   - `peek()` → retrieves (but does not remove) the head (returns null if empty).
   - `element()` → similar to peek but throws exception if empty.

3. Null Handling
   - Most queue implementations do *not* allow null elements.

4. Iteration
   - Provides standard iterator but does not guarantee any specific ordering
     (except in specific implementations like LinkedList).

5. Capacity
   - Some queues are bounded (e.g., ArrayBlockingQueue) and some are unbounded (LinkedList, PriorityQueue).

6. Concurrent Variants
   - `ConcurrentLinkedQueue`, `ArrayBlockingQueue`, `PriorityBlockingQueue` provide thread-safe operations.

Queue Interface Hierarchy (Simplified)
--------------------------------------
Queue (interface)
│
├── Deque (interface)  → Double-ended queue, supports insertion/removal from both ends
│   ├── ArrayDeque
│   └── LinkedList (implements both List & Deque)
│
├── PriorityQueue  → Orders elements by natural order or comparator
│
└── Concurrent queues (from java.util.concurrent)
    ├── ConcurrentLinkedQueue → Unbounded, lock-free, thread-safe
    ├── ArrayBlockingQueue    → Bounded, blocking operations
    ├── LinkedBlockingQueue   → Optionally bounded, blocking operations
    ├── PriorityBlockingQueue → Priority-based ordering with blocking
    └── DelayQueue / SynchronousQueue etc. for advanced use-cases

ASCII Conceptual View (FIFO Queue)
----------------------------------

Offer/Enqueue → [10] → [20] → [30] → [40] → [50] → ...
                ↑head                        ↑tail

Poll/Dequeue removes from head:
  poll() → returns 10
  new head = 20

Special Case (PriorityQueue)
----------------------------
Internally uses a binary heap:
   [5, 10, 15, 20]
   Root (5) is always the minimum (or maximum, depending on comparator).
   poll() removes the root, heap is restructured.

When to Use Queue
-----------------
- When you need FIFO ordering (task scheduling, buffer management).
- When you want priority-based processing (PriorityQueue).
- In concurrent applications (producer-consumer) → use BlockingQueue variants.

Practical Examples
------------------
1. Printer spooler: tasks queued in order of arrival.
2. OS job scheduling: processes waiting in FIFO or priority order.
3. Producer-consumer design: producers put items in a queue, consumers take items from it.
4. Real-time systems: DelayQueue, SynchronousQueue, etc. for advanced coordination.

Complexity
----------
- offer/add: O(1) in linked or array-backed queues.
- poll/remove: O(1) in FIFO queues; O(log n) in PriorityQueue (heap-based).
- peek/element: O(1).
- Iteration: O(n).
