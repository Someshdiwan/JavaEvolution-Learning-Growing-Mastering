An unbounded queue is a queue that can grow indefinitely —
it does not have a fixed capacity limit unless explicitly specified.

In Java:
- `LinkedBlockingQueue` → optionally bounded (default = unbounded, effectively `Integer.MAX_VALUE` capacity).
- `DelayQueue`, `PriorityBlockingQueue` → always unbounded**.

This means producers will never block on `put()` — new elements are always accepted, limited only by available memory.

Unbounded Queue (e.g., `DelayQueue` or `LinkedBlockingQueue`)

          ┌────────────────────────────────────────────┐
          │             Unbounded BlockingQueue        │
          │────────────────────────────────────────────│
Producer →│  [Task1] → [Task2] → [Task3] → [Task4] → … │→ Consumer
          │────────────────────────────────────────────│
          │  • No fixed capacity limit                 │
          │  • Grows dynamically (until memory limit)  │
          │  • put() never blocks                      │
          │  • take() blocks if queue is empty         │
          └────────────────────────────────────────────┘

Bounded Queue (for contrast, e.g., `ArrayBlockingQueue`)

          ┌────────────────────────────┐
          │     Bounded BlockingQueue  │
          │────────────────────────────│
Producer →│ [Slot1] [Slot2] [Slot3]    │→ Consumer
          │────────────────────────────│
          │  • Fixed capacity (e.g., 3)│
          │  • put() blocks if full    │
          │  • take() blocks if empty  │
          └────────────────────────────┘

Summary of Behavior

Queue Comparison Summary

| Queue Type           | Capacity Type | put() when Full             | take() when Empty                | Example Use Case                 |
|----------------------|---------------|-----------------------------|----------------------------------|----------------------------------|
| ArrayBlockingQueue   | Bounded       | Blocks                      | Blocks                           | Producer-consumer with throttling|
| LinkedBlockingQueue  | Unbounded     | Never blocks                | Blocks                           | General producer-consumer pattern|
| DelayQueue           | Unbounded     | Never blocks                | Blocks (until delay expires)     | Task scheduling                  |
| SynchronousQueue     | Zero-capacity | Always blocks until paired  | Always blocks until paired       | Direct handoff                   |


In short:
An unbounded queue trades *backpressure control (throttling producers) for simplicity and flexibility —
excellent for scenarios where the number of queued elements is small or predictable, but risky if production
outpaces consumption.
